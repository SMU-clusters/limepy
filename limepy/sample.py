# -*- coding: utf-8 -*-
from __future__ import division, absolute_import
import numpy
from numpy import exp, sqrt, pi, sin, cos
from scipy.special import gamma, gammainc, dawsn, hyp1f1, erfi
from scipy.optimize import brentq
from scipy import random
from math import factorial

class sample:
    def __init__(self, mod, np, **kwargs):
        r""""
        
        Sample positions and velocities from DF generated by LIMEPY


        Parameters:

        mod : Python object
          Model generated by LIMEPY
        np : scaler
           Number of points to be generated
        seed : scaler, optional
             Random seed 
        verbose : bool, optional
                Print diagnostics; default=False
        """

        self._set_params_and_init(mod, np, **kwargs)
        self.sample_r(mod)
        self.sample_v(mod)
        self.to_cartesian()
        if (self.verbose):
            print " done! "
            f = -self.f*self.mod.sig2 - self.mod.G*self.mod.M/self.mod.rt #/m.sig2
            print "      U: sample = %12.4f; model = %12.4f"%(0.5*sum(self.m*f), mod.U)
            print "      K: sample = %12.4f; model = %12.4f"%(sum(0.5*self.m*self.v**2), mod.K)
            if (self.ani):
                print " 2Kr/Kt: sample = %12.4f; model = %12.4f"%(2*sum(self.vr**2)/sum(self.vt**2),2*mod.Kr/mod.Kt)

    def _set_params_and_init(self, mod, np, **kwargs):
        if not mod.converged: raise ValueError(" This model has not converged, abort sampling ...")
            
        self.seed = 199
        self.verbose = False
        if kwargs is not None:
            for key, value in kwargs.iteritems():
                setattr(self, key, value)

        random.seed(self.seed)  
        self.np = np
        self.mod = mod
        self.m = numpy.zeros(np) + mod.M/np
        self.ani = True if mod.ra/mod.rt < 3 else False

    def sample_r(self, m):
        if (self.verbose): print " sample r ..."
        ran = random.rand(self.np)
        self.r = numpy.interp(ran, m.mc/m.mc[-1], m.r)
        self.f = m.interp_phi(self.r)/m.sig2
        return

    def sample_v(self, m):
        # First sample random values for x = k**1.5
        self.xmax= self.f**1.5

        nx = 10
        self.nx = nx
        frac = numpy.linspace(0,1,nx+1)

        self.x = numpy.zeros(len(self.r))
        for j in range(1,nx):
            self.x = numpy.vstack((self.x, self.xmax*frac[j]))
        self.x = numpy.vstack((self.x, self.xmax))

        self.ycum = numpy.zeros(self.np)        
        if (self.verbose): print " set-up segments for velocity cdf ..."
        self.y = self._pdf_k32(self.r, self.f, self.x[0])
        for j in range(1,nx):
            self._add_segments(self.x[j])
        self.y = numpy.vstack((self.y, 0*self._pdf_k32(self.r, self.f, self.x[-1])))
        if (self.verbose): print " cdf ..."
        self._compute_cdf()

        if (self.verbose): print " sample k^3/2 points ..."
        self.sample_k()

        if (self.ani): self.sample_angles(self.np)

    def _add_segments(self, k):
        self.y = numpy.vstack((self.y, self._pdf_k32(self.r, self.f, k)))

    def _compute_cdf(self):
        for j in range(len(self.x)-1):
            dy = self.y[j]*(self.x[j+1] - self.x[j])
            self.ycum = numpy.vstack((self.ycum, self.ycum[-1]+dy))

    def _Eg(self,x,s):
        return exp(x)*gammainc(s,x) if s>0 else exp(x)

    def _pdf_k32(self, r, f, x):
        # PDF of k^3/2
        g = self.mod.g
        x13 = x**(1./3)
        x23 = x**(2./3)
        E = f-x23

        c = (x>0)
        func = numpy.zeros(len(x))
        if (sum(c)>0):
            if (self.ani): 
                p = r/self.mod.ra
                F = dawsn(x13*p)/p
                func[c] = F[c]/x13[c]*self._Eg(E[c],g) 
            else:
                func[c] = self._Eg(E[c],g) 
        if (sum(~c)>0): func[~c] = self._Eg(E[~c],g) 

        return func
        
    def sample_k(self):
        # y(x) = y_j
        # cdf(x) = ycum_j + y_j*(x - x_j)
        # x = R/y_j + x_j
        np = self.np
        iter=0
        c = numpy.zeros(np, dtype='bool')+True
        mark=1
        while (sum(c) > 0):
            nc = sum(c)
            ycum = self.ycum[:,c]
            rtmp = self.r[c]
            ftmp = self.f[c]
            y = self.y[:,c]
            x = self.x[:,c]

            R = random.rand(nc)*ycum[-1]
            xtmp = numpy.zeros(nc)
            P = numpy.zeros(nc)

            for j in range(self.nx):
                cr = (R>=ycum[j])&(R<ycum[j+1])
                if (sum(cr)>0):
                    xtmp[cr] = (R[cr]-ycum[j,cr])/y[j,cr] + x[j,cr]
                    P[cr] = y[j,cr]

            R2 = random.rand(nc)*P
            f = self._pdf_k32(rtmp, ftmp, xtmp)
            self.R = R
            self.R2 = R2
            c = (R2>f)

            if (iter==0):
                xsamp = xtmp[~c]
                r = rtmp[~c]
                R2sav = R2[~c]

            else:
                xsamp = numpy.r_[xsamp, xtmp[~c]]
                r = numpy.r_[r, rtmp[~c]]
                R2sav = numpy.r_[R2sav, R2[~c]]

            if (self.verbose): print "  iter %i3, %6i left"%(iter, nc)
            iter+=1
            mark=0

        # Assign final velocities and update r because of shuffling
        self.k = xsamp**(2./3)
        self.xsamp = xsamp
        self.xtmp = xtmp
        self.R2sav = R2sav
        self.v = sqrt(2*self.k*self.mod.sig2)
        self.r = r

    def _pdf_angle(self, q, *args):
        # q = cos(theta)
        k,p,R = args
        arg = sqrt(k)*p
        return R  - erfi(arg*q)/erfi(arg)

    def sample_angles(self,np):
        if (self.verbose): print " sample angles ..."
        # For anisotropic systems sample angles: cdf(q) = erfi(a*q)/erfi(a), a = k*p^2
        R = random.rand(np)
        self.Rq = R
        p = self.r/self.mod.ra
        a = self.k*p**2
        self.q = numpy.zeros(np)

        for j in range(np):
            self.q[j] = brentq(self._pdf_angle, 0,1,args=(self.k[j],p[j],R[j]))

        self.vr = self.v*self.q*random.choice((-1,1),size=self.np)
        self.vt = self.v*sqrt(1-self.q**2)

    def to_cartesian(self):
        if (self.verbose): print " convert to cartesian coordinates ..."
        r = self.r
        r2 = r**2
        R1 = random.rand(self.np)
        R2 = random.rand(self.np)
        self.x = (1-2*R1)*self.r
        self.y = sqrt(r2 - self.x**2)*cos(2*pi*R2)
        self.z = sqrt(r2 - self.x**2)*sin(2*pi*R2)
        if (self.ani):
            R1 = random.rand(self.np)
            vphi = self.vt*cos(2*pi*R1)
            vtheta = self.vt*sin(2*pi*R1)
            theta = numpy.arccos(self.z/r)
            phi = numpy.arctan2(self.y, self.x)
            
            self.vx = self.vr*sin(theta)*cos(phi) + vtheta*cos(theta)*cos(phi) - vphi*sin(phi)
            self.vy = self.vr*sin(theta)*sin(phi) + vtheta*cos(theta)*sin(phi) + vphi*cos(phi)
            self.vz = self.vr*cos(theta) - vtheta*sin(theta)
        else:
            v2 = self.v**2
            R1 = random.rand(self.np)
            R2 = random.rand(self.np)
            self.vx = (1-2*R1)*self.v
            self.vy = sqrt(v2 - self.vx**2)*cos(2*pi*R2)
            self.vz = sqrt(v2 - self.vx**2)*sin(2*pi*R2)
